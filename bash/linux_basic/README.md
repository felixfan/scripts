# 1. 基础指令的操作
## 1.1 显示日期的指令: date
## 1.2 显示日历的指令: cal
## 1.3 简单好用的计算器: bc

# 2. 文件与目录的相关操作
## 2.1 cd (change directory, 变换目录)
## 2.2 pwd(显示目前所在的目录)
## 2.3 mkdir(建立新目录)
## 2.4 rmdir(删除『空』的目录)
## 2.5 文件与目录的检视: ls
## 2.6 复制、删除与移动: cp, rm, mv
## 2.7 取得路径的文件名与目录名称: basename, dirname
## 2.8 文件内容查阅: cat, tac, nl, more, less, head, tail
## 2.9 修改文件时间或建置新档: touch
## 2.10 观察文件类型:file
## 2.11 指令与文件的搜寻
### 2.11.1 which (寻找『执行档』)
### 2.11.2 whereis (由一些特定的目录中寻找文件文件名)
### 2.11.3 locate / updatedb
### 2.11.4 find
## 2.12. 关于执行文件路径的变量: $PATH

# 3. 文件系统的简单操作

## 3.1 df:列出文件系统的整体磁盘使用量
## 3.2 du:评估文件系统的磁盘使用量(常用在推估目录所占容量)
## 3.3 实体链接与符号链接: ln

# 4. Linux 系统常见的压缩指令

```
*.Z       compress 程序压缩的文件; *.zip zip 程序压缩的文件;*.gz      gzip 程序压缩的文件;*.bz2     bzip2 程序压缩的文件;*.xz      xz 程序压缩的文件;*.tar     tar 程序打包的数据，并没有压缩过;*.tar.gz  tar 程序打包的文件，其中并且经过 gzip 的压缩 
*.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩 
*.tar.xz  tar 程序打包的文件，其中并且经过 xz 的压缩
```

## 4.1 gzip, zcat/zmore/zless/zgrep

当你使用 gzip 进行压缩时，在预设的状态下原本的文件会被压缩成为 .gz 的档名，**源文件就不再存在了**。  

cat/more/less 可以使用不同的方式来读取纯文本档，那个 zcat/zmore/zless 则可以对应于 cat/more/less 的方式来读取纯文本档被压缩后的压缩文件!  

## 4.2 bzip2, bzcat/bzmore/bzless/bzgrep

若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的。  

## 4.3 xz, xzcat/xzmore/xzless/xzgrep

虽然 xz 这个压缩比真的好太多太多了! xz 最大的问题是时间花太久了!  

## 4.4 打包指令: tar

```
-c : 建立打包文件，可搭配 -v 来察看过程中被打包的档名(filename)-t : 察看打包文件的内容含有哪些档名，重点在察看『档名』就是了;-x : 解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开-z : 透过 gzip 的支持进行压缩/解压缩:此时档名最好为 *.tar.gz 
-j : 透过 bzip2 的支持进行压缩/解压缩:此时档名最好为 *.tar.bz2 
-J : 透过 xz 的支持进行压缩/解压缩:此时档名最好为 *.tar.xz
-v : 在压缩/解压缩的过程中，将正在处理的文件名显示出来!-f filename: -f 后面要立刻接要被处理的档名!
-C 目录 :这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
```

### 4.4.1 仅解开单一文件的方法

```
tar -jxv -f 打包檔.tar.bz2 待解开档名
```

### 4.4.2 仅备份比某个时刻还要新的文件

```
tar -jcv -f test.tar.bz2 --newer-mtime="2015/06/17" /dir/*
```

# 5. bash

## 5.1 命令编修能力 (history): 

只要在指令列按『上下键』就可以找到前/后一个输入的指令!  

## 5.2 命令与文件补全功能: ([tab] 按键的好处)

## 5.3 命令别名设定功能: (alias)

```
alias lm='ls -al'
```

## 5.4 查询指令是否为 Bash shell 的内建命令: type

## 5.5 变量的取用与设定: echo


* 变量与变量内容以一个等号『=』来连结  
* 等号两边不能直接接空格符  
* 变量名称只能是英文字母与数字，但是开头字符不能是数字   
* 变量内容若有空格符可使用双引号『"』或单引号『'』将变量内容结合起来
* 双引号内的特殊字符可以保有原本的特性 
*  单引号内的特殊字符则仅为一般字符 (纯文本)
*  可用跳脱字符『 \ 』将特殊符号
*  在一串指令的执行中，还需要藉由其他额外的指令所提供的信息时，可以使用反单引号『`指令`』
*  若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量
*  通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断
*  取消变量的方法为使用 unset :『unset 变量名称』

## 5.6 用 env 观察环境变量与常见环境变量说明

## 5.7 用 set 观察所有变量 (含环境变量与自定义变量)

## 5.8 export: 自定义变量转成环境变量

## 5.9 数组 (array) 变量类型

```
var[index]=content
```

意思是说，我有一个数组名为 var ，而这个数组的内容为 var[1]=小明，var[2]=大明，var[3]=好明 .... 等等，那个 index 就是一些数字啦，重点是用中刮号 ([ ]) 来设定的。

## 5.10 source :读入环境配置文件的指令

## 5.11 环境配置文件: ~/.bashrc (non-login shell 会读)

## 5.12 数据流重导向

```
- 标准输入 (stdin):代码为0，使用<或<<
- 标准输出 (stdout):代码为 1 ，使用 > 或 >>
- 标准错误输出(stderr):代码为 2 ，使用 2> 或 2>>
```

```
- 1> :以覆盖的方法将『正确的数据』输出到指定的文件或装置上;- 1>>:以累加的方法将『正确的数据』输出到指定的文件或装置上;- 2> :以覆盖的方法将『错误的数据』输出到指定的文件或装置上;- 2>>:以累加的方法将『错误的数据』输出到指定的文件或装置上;
```

```
find /home -name .bashrc > list 2> list  <==错误 
find /home -name .bashrc > list 2>&1     <==正确 
find /home -name .bashrc &> list         <==正确
```
第一行错误的原因是，由于两股数据同时写入一个文件，又没有使用特殊的语法， 此时两股数据可能会交叉写入该文件内，造成次序的错乱。所以虽然最终 list 文件还是会产生，但是里面的数据排列就会怪怪的，而不是原本屏幕上的输出排序。 至于写入同一个文件的特殊语法如上表所 示，你可以使用 2>&1 也可以使用 &>! 一般来说，比较习惯使用 2>&1 的语法啦!

```
echo "error message" 1>&2
echo "error message" 2> /dev/null 1>&2
```
第一条有讯息输出到屏幕上，第二条则没有讯息!这表示该讯息已经是透过 2> /dev/null 丢到垃圾桶去了.

## 5.13 管线命令 (pipe) |

## 5.14 撷取命令: cut, grep

## 5.15 排序命令: sort, wc, uniq

## 5.16 双向重导向: tee

tee 会同时将数据流分送到文件去与屏幕 (screen);而输出到屏幕的，其实就是 stdout ，那就可以让 下个指令继续处理喔!

## 5.17 字符转换命令: tr, col, join, paste, expand

- tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换!
- join 主要是在处理『两个文件当中，有 "相同数据" 的那一行，才将他加在一起』的意思。
- paste 直接 『将两行贴在一起，且中间以 [tab] 键隔开』而已
- expand 就是在将 [tab] 按键转成空格键啦
- col 可以用来简单的处理将 [tab] 按键取代成为空格键

## 5.18 分区命令: split

# 6. 正规表示法 (Regular Expression, RE, 或称为常规表示法)

## 6.1 grep

```
-n 行号
--color=auto 颜色
-v 反向选择
```

### 6.1.1 利用中括号 [] 来搜寻集合字符

其实 [] 里面不论有几个字符，他都仅代表某『一个』字符。    

我不想要 oo 前面有 g 的话， 可以利用在集合字符的反向选择 [^]。  

```
grep -n '[^g]oo' regular_express.txt
```

假设我 oo 前面不想要有小写字符  

```
grep -n '[^a-z]oo' regular_express.txt
```

### 6.1.2 行首与行尾字符

### 6.1.3 任意一个字符 '.' 与重复字符 '*'

-   . (小数点): 代表『一定有一个任意字符』的意思
-   * (星星号): 代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态

### 6.1.4 限定连续 RE 字符范围 {}

```
grep -n 'o\{2\}' regular_express.txt      # 两个 o
grep -n 'go\{2,5\}g' regular_express.txt  # 2 到 5 个 o
grep -n 'go\{2,\}g' regular_express.txt   # 2 个 o 以上
```

## 6.2 sed

```
-i 直接修改读取的文件内容，而不是由屏幕输出。
a :新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)~ 
c :取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行!d :删除，因为是删除啊，所以 d 后面通常不接任何咚咚;i :插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行); 
p :打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作~s :取代，可以直接进行取代的工作哩!通常这个 s 的动作可以搭配正规表示法!
```

### 6.2.1 以行为单位的新增/删除功能

#### 6.2.1.1 将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除!

```
nl /etc/passwd | sed '2,5d'
```

### 6.2.2 部分数据的搜寻并取代的功能

```
sed 's/要被取代的字符串/新的字符串/g'
```

# 7. awk:好用的数据处理工具

awk 也是一个非常棒的数据处理工具!相较于 sed 常常作用于一整个行的处理， awk 则比较倾向 于一行当中分成数个『字段』来处理。因此，awk 相当的适合处理小型的数据数据处理呢!awk 通 常运作的模式是这样的:   

```
awk '条件类型 1{动作 1} 条件类型 2{动作 2} ...' filename```

```
NF   每一行拥有的字段总数
NR   目前 awk 所处理的是『第几行』数据
FS   目前的分隔字符，默认是空格键
逻辑运算： >, <, >=, <=, ==, !=
```

# 8. 文件比对工具

## 8.1 diff

diff 就是用在比对两个文件之间的差异的，并且是以行为单位来比对的!一般是用在 ASCII 纯文本档的比对上。 由于是以行为比对的单位，因此 diff 通常是用在同一的文件(或软件)的新旧版本差异上!  

另外， diff 也可以比对整个目录下的差异喔!  

## 8.2 cmp

cmp 主要也是在比对两个文件。 diff 主要是 以『行』为单位比对， cmp 则是以『字节』为单位去比对，这并不相同!   

# 9. 学习 Shell Scripts

## 9.1 数值运算:简单的加减乘除

bash shell里头预设仅支持到整数的数据而已。  

**注： S应为美元符号**

```
var=S((运算内容))
```

两个小括号内可以加上空格符喔! 至于数值运算上的处理，则有:『 +, -, *, /, % 』等等。 如果你想要计算含有小数点的数据时，其实可以透过 **bc** 这个指令的协助!    

```
echo "123.123*55.9" | bc
```

## 9.2 善用判断式
### 9.2.1 两个整数之间的判定

```
-eq
-ne
-gt
-lt
-ge
-le
```

### 9.2.2 判定字符串的数据

```
==
!=
```

### 9.2.3 利用 test 指令的测试功能

```
test -e /dmtsai              # 检查 /dmtsai 是否存在
```

### 9.2.4 利用判断符号 [ ]

```
[ -e /dmtsai ]
```

如果要在 bash 的语法当中使用中括号作为 shell 的判断式时，必须要注意**中括号的两端需要有空格符来分隔**喔!   

- 在中括号 [] 内的每个组件都需要有空格键来分隔;- 在中括号内的变数，最好都以双引号括号起来;- 在中括号内的常数，最好都以单或双引号括号起来。

## 9.3 条件判断式

### 9.3.1 利用 if .... then

##### 9.3.1.1 单层、简单条件判断式

```
if [ 条件判断式 ]; then    当条件判断式成立时，可以进行的指令工作内容;fi
```

##### 9.3.1.2 多重、复杂条件判断式

```
# 一个条件判断，分成功进行与失败进行 (else) 
if [ 条件判断式 ]; then
    当条件判断式成立时，可以进行的指令工作内容;else 
    当条件判断式不成立时，可以进行的指令工作内容;
fi
```

```
# 多个条件判断 (if ... elif ... elif ... else) 分多种不同情况执行
if [ 条件判断式一 ]; then    当条件判断式一成立时，可以进行的指令工作内容;elif [ 条件判断式二 ]; then 
    当条件判断式二成立时，可以进行的指令工作内容;else 
    当条件判断式一与二均不成立时，可以进行的指令工作内容;
fi
```

### 9.3.2 利用 case ..... esac 判断

**注： S应为美元符号**

```
case S变量名称 in    <==关键词为 case ，还有变数前有钱字号    "第一个变量内容") <==每个变量内容建议用双引号括起来，关键词则为小括号 ) 
        程序段        ;;          <==每个类别结尾使用两个连续的分号来处理! 
    "第二个变量内容")        程序段
        ;;    *)               <==最后一个变量内容都会用 * 来代表所有其他值 
        不包含第一个变量内容与第二个变量内容的其他程序执行段
        exit 1        ;;
esac                 <==最终的 case 结尾!『反过来写』
```

## 9.4 循环 (loop)

### 9.4.1 while do done, until do done (不定循环)

```
while [ condition ]  <==中括号内的状态就是判断式 
do                   <==do 是循环的开始!    程序段落done                 <==done 是循环的结束
```

```
until [ condition ]do    程序段落done
```

### 9.4.2 for...do...done (固定循环)

```
for var in con1 con2 con3 ... 
do    程序段done
```

# 10 进程管理
## 10.1 job control 的管理

### 10.1.1 直接将指令丢到背景中『执行』的 &

### 10.1.2 将『目前』的工作丢到背景中『暂停』:[ctrl]-z

### 10.1.3 观察目前的背景工作状态: jobs

### 10.1.4 将背景工作拿到前景来处理:fg

### 10.1.5 让工作在背景下的状态变成运作中: bg

### 10.1.6 管理背景当中的工作: kill

## 10.2 脱机管理问题

```
nohup [指令与参数]   <== 在终端机前景中工作
nohup [指令与参数] & <== 在终端机背景中工作
```

## 10.3 ps :将某个时间点的进程运作情况撷取下来

### 10.3.1 仅观察自己的 bash 相关进程: 

```
ps -l
```

### 10.3.2 观察系统所有进程: 

```
ps aux
```

## 10.4 top:动态观察进程的变化

## 10.5 系统资源的观察

## 10.5.1 free :观察内存使用情况

## 10.5.2 uname:查阅系统与核心相关信息

P929








 












 
 



